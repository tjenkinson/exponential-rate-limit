{"version":3,"sources":["decaying-value.ts","defer-exception.ts","exponential-rate-limit.ts"],"names":[],"mappings":";AAAa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAb,IAAA,EAAA,WAGE,SAAA,EAAoB,EAAiC,GAAjC,KAAA,OAAA,EAAiC,KAAA,WAAA,EAF7C,KAAA,MAAQ,KAAK,MAiBvB,OAbS,EAAA,UAAA,IAAP,WACQ,IAAA,GAAQ,KAAK,MAAQ,KAAK,OAAS,IAClC,OAAA,KAAK,IAAI,EAAG,KAAK,OAAU,KAAK,WAAa,IAG/C,EAAA,UAAA,IAAP,SAAW,GACJ,KAAA,OAAS,EACT,KAAA,MAAQ,KAAK,OAGb,EAAA,UAAA,UAAP,SAAiB,QAAA,IAAA,IAAA,EAAA,GACV,KAAA,IAAI,KAAK,MAAQ,IAE1B,EAlBA,GAAa,QAAA,cAAA;;ACAb,aAAA,SAAgB,EAAe,GACzB,IACF,IACA,MAAO,GACP,OAAO,WAAW,WACV,MAAA,GACL,IANP,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,eAAA;;ACgBa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAhBb,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,qBAOa,QAAA,qBAAsC,SAAC,GAE9C,OADJ,GAAK,GACG,EACC,EAEF,KAAK,IAAI,IAAK,GAAK,GAG5B,IAAA,EAAA,WAkBE,SAAA,EAAY,GAAA,IAAA,OAAA,IAAA,EAAA,GAAA,EAAE,EAAA,EAAA,YAAA,OAAA,IAAA,EAAA,EAAA,EAAiB,EAAA,EAAA,cAAA,OAAA,IAAA,EAAA,QAAA,qBAAA,EAdvB,KAAA,MAAqB,GACrB,KAAA,OAAyC,KAc1C,KAAA,aAAe,EACf,KAAA,eAAiB,EACjB,KAAA,GAAK,IAAI,EAAA,cAAc,EAAG,EAAI,GAgEvC,OAnDS,EAAA,UAAA,QAAP,SAAe,GAAf,IAAA,EAAA,KACQ,EAAY,CAAE,IAAG,EAAE,SAAU,CAAE,YAAa,KAAK,QAGhD,OAFF,KAAA,MAAM,KAAK,GACX,KAAA,eACE,CACL,OAAQ,WACA,IAAA,EAAQ,EAAK,MAAM,QAAQ,GAC7B,GAAS,IACX,EAAK,MAAM,OAAO,EAAO,GACrB,EAAK,SAAW,EAAK,MAAM,SAC5B,aAAqB,EAAK,QAC3B,EAAK,OAAS,UAOhB,EAAA,UAAA,aAAR,WAAA,IAAA,EAAA,KACM,IAAA,KAAK,OAAL,CAIE,IAAA,EAAY,KAAK,MAAM,QACzB,GAAA,EAAW,CACR,KAAA,GAAG,YACF,IAAA,EAAQ,KAAK,kBAEd,KAAA,OAAU,WAAmB,WAChC,EAAK,OAAS,KACd,EAAK,gBACI,IAAR,GAEH,EAAA,eAAe,WACP,IAAA,EAAM,EAAU,IAAI,EAAU,WACxB,IAAR,EACF,EAAK,GAAG,WAAW,GACV,GAA2B,mBAAb,EAAI,OAC3B,EAAI,KAAK,SAAC,GAAM,OAAA,GAAK,EAAK,GAAG,WAAW,KACf,mBAAd,EAAI,OACb,EAAI,MAAM,WAAM,OAAA,EAAK,GAAG,WAAW,WAOrC,EAAA,UAAA,gBAAR,WACQ,IAAA,EAAW,KAAK,aACf,OAAA,KAAK,IAAI,EAAU,KAAK,eAAe,KAAK,GAAG,MAAO,KAEjE,EArFA,GAAa,QAAA,SAAA","file":"exponential-rate-limit.js","sourceRoot":"../src","sourcesContent":["export class DecayingValue {\n  private _time = Date.now();\n\n  constructor(private _value: number, private readonly _decayRate: number) {}\n\n  public get(): number {\n    const diff = (Date.now() - this._time) / 1000;\n    return Math.max(0, this._value - (this._decayRate * diff));\n  }\n\n  public set(value: number): void {\n    this._value = value;\n    this._time = Date.now();\n  }\n\n  public increment(amount = 1): void {\n    this.set(this.get() + amount);\n  }\n}\n","export function deferException(fn: () => void): void {\n  try {\n    fn();\n  } catch (e) {\n    window.setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n}\n","import { DecayingValue } from './decaying-value';\nimport { deferException } from './defer-exception';\nimport { Config, DelayFunction, Job, JobHolder } from './types';\n\n/**\n * This delay function will allow the first 4 jobs to be executed immediately,\n * and then start increasing the delay exponentially.\n */\nexport const defaultDelayFunction: DelayFunction = (x: number/*, maxDelay: number */) => {\n  x -= 4;\n  if (x < 0) {\n    return 0;\n  }\n  return Math.pow(1.1, x) - 1;\n};\n\nexport class JobQueue {\n  private readonly _x: DecayingValue;\n  private readonly _maxInterval: number;\n  private readonly _delayFunction: DelayFunction;\n  private _jobs: JobHolder[] = [];\n  private _timer: NodeJS.Timeout | number | null = null;\n\n  /**\n   * Construct an instance of `JobQueue`.\n   *\n   * The following configuration may be provided:\n   * - `maxInterval`: The maximum number of seconds to wait between jobs. The time it takes for\n   *                  the interval to reach this depends on `delayFunction`. Defaults to 5 seconds.\n   * - `delayFunction`: A functon that returns the amount of seconds to wait before the next job\n   *                    should be executed. Defaults to `defaultDelayFunction`, which will allow the\n   *                    first 4 jobs to execute immediately, and then the delays will increase\n   *                    exponentially untill `maxInterval` is reached.\n   */\n  constructor({ maxInterval = 5, delayFunction = defaultDelayFunction }: Config = {}) {\n    this._maxInterval = maxInterval;\n    this._delayFunction = delayFunction;\n    this._x = new DecayingValue(0, 1 / maxInterval);\n  }\n\n  /**\n   * Enqueue a job to be executed asynchonously.\n   *\n   * This returns an object with a `remove` function, which when called will remove the job\n   * from the queue, meaning it will not be executed (if this hasn't already happened).\n   *\n   * @param job A function which will be executed asychronously. It will receive `JobMetadata`,\n   *            which includes the time the job was queued. If it returns `true` or a promise\n   *            that resolves with `true` (or rejects), the delays between jobs will start decreasing.\n   */\n  public enqueue(job: Job): { remove: () => void } {\n    const jobHolder = { job, metadata: { enqueueTime: Date.now() } };\n    this._jobs.push(jobHolder);\n    this._executeNext();\n    return {\n      remove: () => {\n        const index = this._jobs.indexOf(jobHolder);\n        if (index >= 0) {\n          this._jobs.splice(index, 1);\n          if (this._timer && !this._jobs.length) {\n            (clearTimeout as any)(this._timer);\n            this._timer = null;\n          }\n        }\n      },\n    };\n  }\n\n  private _executeNext(): void {\n    if (this._timer) {\n      return;\n    }\n\n    const jobHolder = this._jobs.shift();\n    if (jobHolder) {\n      this._x.increment();\n      const delay = this._calculateDelay();\n      // support browser and node\n      this._timer = (setTimeout as any)(() => {\n        this._timer = null;\n        this._executeNext();\n      }, delay * 1000);\n\n      deferException(() => {\n        const res = jobHolder.job(jobHolder.metadata);\n        if (res === true) {\n          this._x.increment(-2);\n        } else if (res && typeof res.then === 'function') {\n          res.then((a) => a && this._x.increment(-2));\n          if (typeof res.catch === 'function') {\n            res.catch(() => this._x.increment(-2));\n          }\n        }\n      });\n    }\n  }\n\n  private _calculateDelay(): number {\n    const maxDelay = this._maxInterval;\n    return Math.min(maxDelay, this._delayFunction(this._x.get(), maxDelay));\n  }\n}\n"]}